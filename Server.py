# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'untitled.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

#from PySide2.QtCore import (QAbstractTableModel, QDateTime, QModelIndex,
#                            Qt, QTimeZone, Slot)
#from PySide2.QtGui import QColor
#from PySide2.QtWidgets import (QAction, QApplication, QHBoxLayout, QHeaderView, QTableView,
#                               QMainWindow, QPushButton, QSizePolicy, QWidget)

from PyQt5 import QtGui, QtWidgets, QtCore
import pandas as pd
import socket
from threading import Thread 
from socketserver import ThreadingMixIn 
import datetime


class CustomTableModel(QtCore.QAbstractTableModel):
    def __init__(self, data):
        super(CustomTableModel, self).__init__()
        self.load_data(data)

    def load_data(self, data):
        self.input_Users = data[0].values
        self.input_Inicio = data[1].values
        self.input_Fim = data[2].values
        self.input_Atividade = data[3].values

        self.column_count = 4
        self.row_count = len(self.input_Atividade)

    def rowCount(self, parent=QtCore.QModelIndex()):
        return self.row_count

    def columnCount(self, parent=QtCore.QModelIndex()):
        return self.column_count

    def headerData(self, section, orientation, role):
        if role != QtCore.Qt.DisplayRole:
            return None
        if orientation == QtCore.Qt.Horizontal:
            
            return ("Usuario", "Inicio", 'Fim', 'Atividade')[section]
        else:
            return "{}".format(section)

    def data(self, index, role = QtCore.Qt.DisplayRole):
        column = index.column()
        row = index.row()

        if role == QtCore.Qt.DisplayRole:
            if column == 0:
                raw_user = self.input_Users[row]
                
                return raw_user
            elif column == 1:
                return self.input_Inicio[row]
            elif column==2:
                return self.input_Fim[row]
            elif column==3:
                return self.input_Atividade[row]

        elif role == QtCore.Qt.BackgroundRole:
            return QtGui.QColor(QtCore.Qt.white)
        elif role == QtCore.Qt.TextAlignmentRole:
            return QtCore.Qt.AlignRight

        return None

class Ui_MainWindow(object):
    def setupUi(self, MainWindow, df):
        data=self.read_data(df)
        self.cond=True
        self.df=df
        
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(520, 398)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.Ring = QtWidgets.QComboBox(self.centralwidget)
        self.Ring.setGeometry(QtCore.QRect(160, 20, 201, 22))
        self.Ring.setObjectName("Ring")
        self.Ring.addItem('Todos os usuarios')
        for item in list(self.df.Usuario.unique()):
            self.Ring.addItem(item)
        self.Ring.activated.connect(self.selecionar)

        self.Tabela = QtWidgets.QTableView(self.centralwidget)
        self.Tabela.setGeometry(QtCore.QRect(20, 60, 474, 301))
        self.Tabela.setObjectName("Tabela")
        self.Tabela.modelo=CustomTableModel(data)
        self.Tabela.setModel(self.Tabela.modelo)
        self.horizontal_header = self.Tabela.horizontalHeader()
        self.vertical_header = self.Tabela.verticalHeader()
        self.horizontal_header.setSectionResizeMode(QtWidgets.QHeaderView.ResizeToContents)
        self.vertical_header.setSectionResizeMode(QtWidgets.QHeaderView.ResizeToContents)
        self.horizontal_header.setStretchLastSection(False)


        self.Button = QtWidgets.QPushButton(self.centralwidget)
        self.Button.setGeometry(QtCore.QRect(20, 20, 131, 23))
        self.Button.setObjectName("Button")
        self.Button.clicked.connect(self.clickme)

        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 450, 21))
        self.menubar.setObjectName("menubar")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Users activities"))
        self.Button.setText(_translate("MainWindow", "Tarefas em andamento?"))

    def read_data(self, df):
        # Read the CSV content
        Usuarios = df["Usuario"]
        Inicio=df.Inicio
        Fim=df.Fim
        Atividade=df.Atividade

        return Usuarios, Inicio, Fim, Atividade
    def mod(self):
        global cond
        df=pd.read_csv('Base.csv')
        
        data = self.read_data(df)
        x = CustomTableModel(data)
        self.model=x
        self.Tabela.setModel(x)
        self.df=df
        return list(df.Usuario.unique())

    def clickme(self):
        self.cond=not(self.cond)
        self.selecionar()
           

    def selecionar(self):

        aux=str(self.Ring.currentText())
        df=pd.read_csv('Base.csv')
        #print(aux)
        if (self.cond==True) and (aux=='Todos os usuarios'):
            df=df
            
            new=self.read_data(df)
            self.Tabela.setModel(CustomTableModel(new))
        
        elif (self.cond==False) and (aux=='Todos os usuarios'):
            df=df.loc[df.Fim=='Em andamento']
            
            new=self.read_data(df)
            self.Tabela.setModel(CustomTableModel(new))
        
        elif (self.cond==True) and (aux!='Todos os usuarios'):
            df=df.loc[df.Usuario==aux]
            new=self.read_data(df)
            self.Tabela.setModel(CustomTableModel(new))
        
        elif (self.cond==False) and (aux!='Todos os usuarios'):
            df=df.loc[(df.Usuario==aux)&(df.Fim=='Em andamento')]
            new=self.read_data(df)
            self.Tabela.setModel(CustomTableModel(new))

class ServerThread(Thread):
    def __init__(self,window): 
        Thread.__init__(self) 
        self.window=window

    def run(self): 
        TCP_IP = '25.64.19.191' 
        TCP_PORT = 80 
        BUFFER_SIZE = 20  
        tcpServer = socket.socket(socket.AF_INET, socket.SOCK_STREAM) 
        tcpServer.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) 
        tcpServer.bind((TCP_IP, TCP_PORT)) 
        threads = [] 
        
        tcpServer.listen(4) 
        while True:
            print("Multithreaded Python server : Waiting for connections from TCP clients...") 
            global conn
            (conn, (ip,port)) = tcpServer.accept() 
            newthread = ClientThread(ip,port,self.window) 
            newthread.start() 
            threads.append(newthread) 
        
        for t in threads: 
            t.join() 

class ClientThread(Thread): 
 
    def __init__(self,ip,port,window): 
        Thread.__init__(self) 
        self.window=window
        self.ip = ip 
        self.port = port 
        print("[+] New server socket thread started for " + ip + ":" + str(port)) 
 
    def run(self): 
        while True : 
            
            #(conn, (self.ip,self.port)) = serverThread.tcpServer.accept() 
            global conn
            data = conn.recv(2048) 
            global dictio
            dictio=eval(data)
            #print(data)
            print(dictio)
            self.update_data()
            #print(self.window.Tabela.modelo)
            n=self.window.mod()
            #print(widget.model)
            #self.window.Tabela.setModel(self.window.Tabela.modelo)
           
            
    def update_data(self):
        base=pd.read_csv('Base.csv')
        new_information=pd.DataFrame(dictio)
        nome_new=((new_information.Usuario))
        #print(type(nome_new))
        #print(nome_new)
        #print(nome_new[0])
        nome_new=str(nome_new[0])
        
        (base.loc[((base.Usuario)==nome_new)&(base.Fim=='Em andamento'), 'Fim'])=datetime.datetime.now()
        base=base.append(new_information, ignore_index=True)
        base.to_csv('Base.csv', index=False)    



if __name__ == "__main__":
    import sys
    data=pd.read_csv('Base.csv')
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow, data)

    serverThread=ServerThread(ui)
    serverThread.start()

    MainWindow.show()
    sys.exit(app.exec_())
    
